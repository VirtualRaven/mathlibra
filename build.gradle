/* Copyright (C) 2016 Lukas Rahmn, Anton Fredriksson
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

apply plugin: "cpp"
	task createGitHeader<< {
		println "Updating git info..."
                def tmp = "git describe --long --dirty=-D".execute()
		tmp.waitForOrKill(10000)
		if(tmp.exitValue() != 0){
		    throw new GradleException("Could not get git info")
		}
			
		def fileContent = { tag, number, sha -> 
                """
                #define GIT_NAME \"${tag}\"
                #define GIT_SHA  \"${sha}\"
                #define GIT_NUM  \"${number}\"
                """
		}
                project.buildDir.mkdirs()  
	        def res = tmp.text.split("-",4)
	        if(res.size() >= 3 && res.size() <= 4){
                        project.ext.set("version",res[0].trim())
                        project.ext.set("DIRTY",res.size()==4)
	        	new File(project.buildDir.getAbsolutePath()+ "/GIT_VERSION.h").withWriter { out ->
	        		out.print fileContent(res[0].trim(),res[1].trim(),res[2].trim())
	        		if(res.size() == 4){
	        			out.println "#define GIT_DIRTY"
	        		}
	        	}
	        }
	        else{
	        	throw new GradleException("Output from git describe not understood")
	        }	
                
		println "Git update done"

	    }
         
            task copyGitHeader(type: Copy){
                from(project.projectDir){
                    include("GIT_VERSION.h")
                }
                into(project.buildDir)
            }
        task git << {
        }
        git.dependsOn( file(project.projectDir.getAbsolutePath()+"/GIT_VERSION.h").exists() ? copyGitHeader : createGitHeader)
    
        
model
{
	toolChains {
		
		gcc(Gcc){
			target("linux_x86"){
			
				cppCompiler.withArguments { args ->
					args << "-m32" 
				}
				linker.withArguments { args ->
					args << "-m32" 
				}
			}
			target("linux_x64"){
				cppCompiler.withArguments { args ->
					args << "-m64" 
				}
				linker.withArguments { args ->
					args << "-m64" 
				}
			}
		}
		arm(Gcc){
			if (project.hasProperty('ndktoolchain'))
				path project.properties['ndktoolchain']
			target("armeabiv7a")	
		}
		cygwin(Gcc){
			target("windows_x86")
			target("windows_x64")
		}
		clang(Clang){
			target("osx_x86")
			target("osx_x64")
		}
		
	}
	
	platforms {
		armeabiv7a{
			architecture "arm"
			operatingSystem "linux"
		}
		linux_x86{
			architecture "x86"
			operatingSystem "linux"
		}
		linux_x64{
			architecture "x86_64"
			operatingSystem "linux"
		}
		windows_x86 {
                	architecture "x86"
                	operatingSystem "windows"
        	}
        	windows_x64 {
                	architecture "x86_64"
                	operatingSystem "windows"
        	}
        	osx_x86 {
                	architecture "x86"
                	operatingSystem "osx"
        	}
        	osx_x64 {
                	architecture "x86_64"
                	operatingSystem "osx"
        	}
		current{
		}
	}	
	
	buildTypes {
		debug
		release
	}
	tasks{
                    
                createTest0(Copy){
                   dependsOn $.binaries.withType(NativeExecutableBinarySpec).findAll(
                                    {
                                        it.targetPlatform.name.contains("current") && 
                                        it.toString().contains("mathlibra_CXX_client") && 
                                        it.buildType.name.contains("debug")
                                    })
                   dependsOn $.binaries.withType(SharedLibraryBinarySpec).findAll(
                                    {
                                        it.targetPlatform.name.contains("current") && 
                                        it.toString().contains("mathlibra_CXX") && 
                                        it.buildType.name.contains("debug")
                                    })
                    from "$buildDir/libs/mathlibra_CXX/shared/current/debug"
                    from "$buildDir/exe/mathlibra_CXX_client/current/debug"
                    into "$buildDir/user_test"
                }
                build_release(Task){
                    dependsOn $.binaries.findAll( { it.buildType.name.contains("release") && it.buildable })
                }

                createTest1(Copy){
                    from "tests/"
                    include "*.txt"
                    into "$buildDir/user_test"
                }
                runTest(Exec){
                 2.times{ i -> dependsOn "createTest$i" }
                  workingDir "$buildDir/user_test"
                  commandLine './mathlibra_CXX_client', "-f" , "main.txt"   
                }
		createPyTest0(Copy){
		dependsOn $.binaries.withType(SharedLibraryBinarySpec).findAll({ it.toString().contains("mathlibra_C") && it.buildable })
		from "$buildDir/libs/mathlibra_C/shared/current/debug/"
		include "*.so"
		into "$buildDir/py_test"}
		
		createPyTest1(Copy){
		from "wrapper/c_api_interface/"
		include "*.py"
		into "$buildDir/py_test"}
		
		runPyTest(Exec){
			2.times{ i-> 
				dependsOn "createPyTest$i"
			}
			workingDir "$buildDir/py_test"
			commandLine 'python', "run_tests.py"
		}
                test(Task){
                    dependsOn runPyTest
                    dependsOn runTest
                }
		run(Task){
			description "Runs core tester, must be run with --no-daemon" 
			dependsOn $.binaries.withType(NativeExecutableBinarySpec).findAll({it.buildable && it.targetPlatform.name.contains("current") && it.toString().contains("core_tester")})
			doLast{
   			

    				def proc = new ProcessBuilder("$buildDir/exe/core_tester/current/debug/core_tester")
        			.redirectOutput(ProcessBuilder.Redirect.INHERIT)
        			.redirectInput(ProcessBuilder.Redirect.INHERIT)
        			.redirectError(ProcessBuilder.Redirect.INHERIT)
        			.start()
    				proc.waitFor()

    				if (0 != proc.exitValue()) {
        				throw new RuntimeException("console exited with status: ${proc.exitValue()}")
    				}
			}
			
		}
		mkCXXApi(Copy){
			from "wrapper/common/main_wrapper.h"
			from "core/core/type_interface.h"
			from "core/core/type.h"
			from "core/core/type_enum.h"
			from "core/ptr_protect.h"
			from "core/exception_helper.h"
			from "core/exception.h"
			from "wrapper/c++_wrapper/export.h"
			rename { String fileName -> "mathlibra_CXX/include/" + fileName}
			into "$buildDir/mkCXXApi"
		}
		mkCApi(Copy){
			from "wrapper/c_api_interface/c_api.h"
			from "core/core/type_enum.h"
			rename { String fileName -> "mathlibra_C/include/" + fileName }
			into "$buildDir/mkCApi"
		}	
                mkPluginApi(Zip){
                        from "core/modules/function_helper.h"
                        from "core/plugins/functions_external_interface.h"
                        from "core/core/mathNode_interface.h"
                        from "core/ptr_protect.h"
                        from "core/core/tree_interface.h"
                        from "core/core/type.h"
                        from "core/core/type_interface.h"
                        from "core/core/type_enum.h"
                        from "core/modules/recursion_types.h"
                        baseName "plugin_api"
                        destinationDir project.buildDir 
                }
		zip(Zip){
			baseName "mathlibra"
			dependsOn $.binaries.findAll { it.buildable }
			dependsOn git
			destinationDir project.buildDir
			from project.buildDir.getAbsolutePath() + "/libs"
			from mkCXXApi
			from mkCApi
			exclude "core_lib"	
			
		}
	}
	
	binaries{
		all{	
			if(!((targetPlatform.getName() == "current") || (project.hasProperty(targetPlatform.getName())))){
				buildable = false
			}	
			if (targetPlatform == platforms.current){
				for(NativePlatform p : platforms){
					if(project.hasProperty(p.getName())){
						buildable = false
					}
				}
			}
			if (buildable && targetPlatform.getName()=="armeabiv7a" && !project.hasProperty('ndktoolchain')){
				buildable = false
				throw new GradleException("No ndktoolchain set")
			}
			if(buildType == buildTypes.debug)
			{
				cppCompiler.define "DEBUG"
				cppCompiler.define "TYPE_MEM_TEST"
                                if(project.hasProperty('LEXICAL_DEBUG'))
                                {
                                    cppCompiler.define "LEXICAL_ANANALYSIS_DEBUG"
                                }
			}
                        if(project.hasProperty('NON_STRICT'))
                        {
                            cppCompiler.define "NON_STRICT_PARANTHESES"

                        }
                        if(project.hasProperty('TEAMCITY'))
                        {
                            cppCompiler.define "TEAMCITY"
                        }
			if(toolChain in Gcc)
			{
                                if(buildType == buildTypes.release)
                                {
                                    if(project.hasProperty('CXX'))
                                        cppCompiler.args  project.properties['CXX'].split(' ')
                                    if(project.hasProperty('LD'))
                                        linker.args  project.properties['LD'].split(' ')
                                }
				if(buildType == buildTypes.release)
				{
					cppCompiler.args "-std=c++11", "-O2","-Wall","-pedantic","-fPIC"
					linker.args "-ldl"
				}
				else
				{
					cppCompiler.args "-std=c++11","-Wall","-pedantic","-g","-fPIC"
					linker.args "-ldl"
				}
			}else if(toolChain in Clang)
			{
				if(buildType == buildTypes.release)
				{
					cppCompiler.args "-std=c++11", "-O2","-Wall","-pedantic","-fPIC"
					linker.args "-ldl"
				}
				else
				{
					cppCompiler.args "-std=c++11","-Wall","-pedantic","-g","-fPIC"
					linker.args "-ldl"
				}
			}
		}
		withType(NativeExecutableBinarySpec) {
			
			if(toolChain in Gcc)
			{
					linker.args "-pie"
			}
        	}
	}
	components {
		core_lib(NativeLibrarySpec) {
			targetPlatform "armeabiv7a"
			targetPlatform "linux_x86"
			targetPlatform "linux_x64"
			targetPlatform "windows_x86"
			targetPlatform "windows_x64"
			targetPlatform "osx_x86"
			targetPlatform "osx_x64"
			targetPlatform "current"
			binaries.all{
				if(toolChain in Gcc)
				{
					cppCompiler.args "-fPIC"
				}
				if(targetPlatform.operatingSystem.isLinux()){
					cppCompiler.define "LINUX"
				}
				else if(targetPlatform.operatingSystem.isWindows()){
					cppCompiler.define "WINDOWS"
				}
				else if(targetPlatform.operatingSystem.isMacOsX()){
					cppCompiler.define "LINUX"
				}
				else{
					throw new GradleException("Platform unknown, cannont select plugin loader")
				}
			}
			sources {
				cpp{
					source {
						srcDirs "core/core/",
							"core/core/modules",
							"core/core/plugins",
							"core/",
							"core/interface"
						
						include "**/*.cpp"
					}
					exportedHeaders {
						srcDirs "core/core/",
							"core/core/modules",
							"core/core/plugins",
							"core/",
							"core/interface"
						include "**/*.h"
					}
					lib sources.generated
				}
				generated(CppSourceSet){
					exportedHeaders {
						srcDirs  project.buildDir.getAbsolutePath()
						include "GIT_VERSION.h"
					}
					builtBy git
				}
				
				
			}
		}
		
		core_tester(NativeExecutableSpec)
		{	
			targetPlatform "armeabiv7a"
			targetPlatform "linux_x86"
			targetPlatform "linux_x64"
			targetPlatform "windows_x86"
			targetPlatform "windows_x64"
			targetPlatform "osx_x86"
			targetPlatform "osx_x64"
			targetPlatform "current"
			sources{
				cpp{
					cpp.lib library: "core_lib", linkage: "static"
					source{
						srcDirs "tester"
						include "*.cpp"
						}
					exportedHeaders
					{
						srcDirs "tester"
						include "*.h"
					}
				}
			}
		}
		mathlibra_CXX(NativeLibrarySpec)
		{
			targetPlatform "armeabiv7a"
			targetPlatform "linux_x86"
			targetPlatform "linux_x64"
			targetPlatform "windows_x86"
			targetPlatform "windows_x64"
			targetPlatform "osx_x86"
			targetPlatform "osx_x64"
			targetPlatform "current"
                        binaries.all{
                            if(toolChain in Gcc){
                              if(project.hasProperty('CPP-CXX')){
                                  cppCompiler.args  project.properties['CPP-CXX'].split(' ')
                                  print "Using extra compiler args for mathlibra_CXX\n"
                                  println project.properties['CPP-CXX']
                                }
                              if(project.hasProperty('CPP-LD')){
                                  linker.args  project.properties['CPP-LD'].split(' ')
                                  print "Using extra linker args for mathlibra_CXX\n"
                                  println project.properties['CPP-LD']
                                }
                            }
                        }
			sources{
				cpp{
					lib library: "core_lib", linkage: "static"
					source{
						srcDirs "wrapper/c++_wrapper", "wrapper/common"
						include "*.cpp"
					}
					exportedHeaders{
						srcDirs "wrapper/c++_wrapper", 
							"wrapper/common",
							"wrapper"
						include "*.h"
					}	
				}
					
			}				
		}
		mathlibra_C(NativeLibrarySpec)
		{
			targetPlatform "armeabiv7a"
			targetPlatform "linux_x86"
			targetPlatform "linux_x64"
			targetPlatform "windows_x86"
			targetPlatform "windows_x64"
			targetPlatform "osx_x86"
			targetPlatform "osx_x64"
			targetPlatform "current"
                        binaries.all{
                            if(toolChain in Gcc){
                              if(project.hasProperty('C-CXX')){
                                  cppCompiler.args  project.properties['C-CXX'].split(' ')
                                  print "Using extra compiler args for mathlibra_C\n"
                                  println project.properties['C-CXX']
                                }
                              if(project.hasProperty('C-LD')){
                                  linker.args  project.properties['C-LD'].split(' ')
                                  print "Using extra linker args for mathlibra_C\n"
                                  println project.properties['C-LD']
                                }
                            }
                        }
			sources{
				cpp{
					lib library: "core_lib", linkage: "static"
					source{
						srcDirs "wrapper/c_api_interface", "wrapper/common"
						include "*.cpp"
					}
					exportedHeaders{
						srcDirs "wrapper/c_api_interface", "wrapper/common"
						include "*.h"
					}	
					}
				}
				
		}
		mathlibra_CXX_client(NativeExecutableSpec)
		{       

                        binaries.all{
                            if(toolChain in Gcc){
                                linker.args  "-Wl,-rpath,./"
                            }
                        }	
			targetPlatform "armeabiv7a"
			targetPlatform "linux_x86"
			targetPlatform "linux_x64"
			targetPlatform "windows_x86"
			targetPlatform "windows_x64"
			targetPlatform "osx_x86"
			targetPlatform "osx_x64"
			targetPlatform "current"
			sources{
				cpp{
					lib library: "mathlibra_CXX", linkage: "shared"
					lib library: "core_lib", linkage: "api"
					source{
						srcDirs "wrapper/c++_wrapper_client"
						include "*.cpp"
					}
					exportedHeaders{
						srcDirs "wrapper/c++_wrapper_client"
						include "*.h"
					}	
					}
				}
		}
		
	}		
}

